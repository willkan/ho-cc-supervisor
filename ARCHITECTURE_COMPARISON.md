# Supervisor-ME 架构方案对比

## 方案一：当前双窗口文件监控方案

```ascii
┌─────────────────────────────────────────────────────────────┐
│                     开发者视角                               │
└─────────────────────────────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    ▼                   ▼
        ┌──────────────────┐  ┌──────────────────┐
        │   Window 1        │  │   Window 2        │
        │   [Worker]        │  │   [Supervisor]    │
        └──────────────────┘  └──────────────────┘
                    │                   │
                    ▼                   ▼
        ┌──────────────────┐  ┌──────────────────┐
        │  worker-wrapper   │  │ session-monitor   │
        │                   │  │                   │
        │  ┌─────────────┐ │  │  ┌─────────────┐ │
        │  │ Claude Code │ │  │  │  File Watch │ │
        │  └─────────────┘ │  │  └─────────────┘ │
        │         │         │  │         │         │
        │         ▼         │  │         ▼         │
        │   Write Session   │  │   Read Session    │
        └──────────────────┘  └──────────────────┘
                    │                   │
                    ▼                   ▼
        ┌──────────────────────────────────────┐
        │     .super/worker-session.log        │
        │   [实时写入]          [轮询读取]      │
        └──────────────────────────────────────┘

时序流程:
1. 用户 → Worker: 输入任务
2. Claude → Session Log: 写入操作记录
3. Monitor → Session Log: 每100ms轮询
4. Monitor: 检测到完成模式
5. Monitor → Tests: 运行测试验证
6. Monitor → Inquiries: 生成智能提问
7. Supervisor → 用户: 显示验证结果
```

### 优点
- 完全解耦，Worker 和 Supervisor 独立运行
- 可以随时启动/停止 Supervisor
- 保留完整会话历史供后续分析
- 不影响 Claude Code 原生行为

### 缺点
- 需要手动启动两个窗口
- 基于轮询，有延迟（100ms-1s）
- 需要解析日志识别模式（可能误判）
- 文件 I/O 开销

---

## 方案二：Hooks 方案（prompt-post-hook）

```ascii
┌─────────────────────────────────────────────────────────────┐
│                     开发者视角                               │
└─────────────────────────────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    ▼                   ▼
        ┌──────────────────┐  ┌──────────────────┐
        │  Claude Code CLI  │  │  监控输出(可选)   │
        │                   │  │                   │
        │  用户 ←→ Claude   │  │   tail -f logs    │
        └──────────────────┘  └──────────────────┘
                    │
                    ▼
        ┌──────────────────────────────────────┐
        │         Claude Code 内部             │
        │                                       │
        │  任务执行 → 完成 → 等待用户输入      │
        │            │                          │
        │            ▼                          │
        │    [prompt-post-hook 触发]           │
        └──────────────────────────────────────┘
                    │
                    ▼
        ┌──────────────────────────────────────┐
        │      supervisor-verify.sh             │
        │                                       │
        │  1. 分析刚完成的任务                 │
        │  2. 运行相关测试                     │
        │  3. 生成验证报告                     │
        │  4. 显示给用户                       │
        └──────────────────────────────────────┘

触发时机:
• 用户输入任务 → Claude 执行
• Claude 完成 todo 1 → 停下等待 → [Hook 触发] → 验证
• 用户确认继续 → Claude 执行 todo 2
• Claude 完成 todo 2 → 停下等待 → [Hook 触发] → 验证
• 用户按 ESC 中断 → [Hook 触发] → 状态检查
• Claude 完成所有任务 → [Hook 触发] → 全面验证
```

### 优点
- 单窗口操作，用户体验简单
- 同步触发，零延迟
- 精准触发时机（任务完成点）
- 无文件轮询开销
- 原生集成，更稳定

### 缺点
- 需要配置 ~/.claude/settings.json
- Hook 执行会短暂阻塞（可优化为后台）
- 依赖 Claude Code 的 Hook 机制

---

## 方案三：Session 文件监控方案

```ascii
┌─────────────────────────────────────────────────────────────┐
│                     开发者视角                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
        ┌──────────────────────────────────────┐
        │         Claude Code CLI               │
        │                                       │
        │    用户 ←→ Claude (正常交互)          │
        └──────────────────────────────────────┘
                              │
                              ▼
        ┌──────────────────────────────────────┐
        │   ~/.claude/project/{session-id}/    │
        │                                       │
        │   ├── messages.jsonl  [对话历史]     │
        │   ├── tools.jsonl     [工具调用]     │
        │   └── state.json      [会话状态]     │
        └──────────────────────────────────────┘
                              ▲
                              │
                    ┌─────────┴─────────┐
                    │   文件系统监控     │
                    │   (fswatch/inotify)│
                    └───────────────────┘
                              ▲
                              │
        ┌──────────────────────────────────────┐
        │      supervisor-daemon                │
        │                                       │
        │  1. 监控 session 文件变化            │
        │  2. 解析 JSONL 格式数据              │
        │  3. 检测任务完成模式                  │
        │  4. 触发验证和测试                    │
        │  5. 生成报告(另存)                    │
        └──────────────────────────────────────┘

后台守护进程模式:
• Supervisor 作为守护进程运行
• 自动检测新 session 创建
• 实时监控所有 Claude 会话
• 验证结果写入独立日志文件
• 用户可随时查看验证报告
```

### 优点
- 完全透明，不影响 Claude 交互
- 可以监控所有历史会话
- 结构化数据（JSONL），解析准确
- 可实现高级分析（跨会话学习）

### 缺点
- 需要了解 Claude 内部文件格式
- 文件格式可能变化（版本依赖）
- 需要持续运行守护进程
- 复杂度最高

---

## 方案对比表

| 特性 | 双窗口监控 | Hooks方案 | Session监控 |
|------|-----------|-----------|-------------|
| **用户体验** | 需要两个窗口 | 单窗口 | 完全透明 |
| **实时性** | 100ms延迟 | 实时 | 实时 |
| **准确性** | 模式匹配 | 精准触发 | 结构化数据 |
| **性能开销** | 文件轮询 | 最小 | 文件监控 |
| **实现复杂度** | 中等 | 简单 | 复杂 |
| **可靠性** | 中等 | 高 | 取决于格式稳定性 |
| **维护成本** | 低 | 最低 | 高 |
| **扩展性** | 中等 | 受限于Hooks | 最高 |

---

## 推荐方案（基于最新理解）

### 核心理念转变
**ESC 中断 = 用户主动控制，不是错误**
- 用户按 ESC 是为了接管控制，不需要验证
- 只有 Claude 认为"完成"的任务才需要验证
- Stop hook 不在 ESC 时触发，这是特性而非缺陷

### 短期（MVP）：**简化的 Hooks 方案** ⭐
```json
{
  "hooks": {
    "Stop": "~/supervisor-me-mvp/hooks/verify-completion.sh",
    "PostToolUse": {
      "Write": "~/supervisor-me-mvp/hooks/syntax-check.sh",
      "Edit": "~/supervisor-me-mvp/hooks/syntax-check.sh"
    },
    "UserPromptSubmit": "~/supervisor-me-mvp/hooks/log-intent.sh"
  }
}
```

**理由**：
1. Stop hook 精准验证 Claude 完成的任务
2. ESC 中断时不触发验证（符合用户意图）
3. PostToolUse 提供即时语法检查
4. UserPromptSubmit 记录用户意图用于学习

### 长期（高级功能）：**混合方案**
- 使用 Hooks 进行实时验证（主路径）
- 使用 Session 监控进行历史分析和学习
- 提供可选的双窗口监控模式用于调试

---

## 验证哲学：什么需要验证，什么不需要

### ✅ 需要验证的场景
1. **Claude 说"完成了"**（Stop hook 触发）
   - 验证：任务是否真的完成
   - 验证：代码是否能运行
   - 验证：测试是否通过

2. **Claude 创建/修改文件**（PostToolUse 触发）
   - 验证：语法是否正确
   - 验证：是否引入明显错误

3. **Claude 执行重要操作**
   - 验证：数据库迁移是否成功
   - 验证：部署是否正常

### ❌ 不需要验证的场景
1. **用户按 ESC 中断**
   - 原因：用户主动控制，知道自己在做什么
   - 响应：记录但不验证

2. **部分完成的任务**
   - 原因：用户可能改变主意
   - 响应：保持现状，等待新指令

3. **用户快速切换任务**
   - 原因：探索性工作的正常模式
   - 响应：跟随用户节奏

### 🎯 核心原则
**验证是为了帮助，不是监督**
- 当 Claude 认为完成时，帮用户确认质量
- 当用户接管时，退到后台不干扰
- 验证结果是建议，不是强制

---

## 实施建议

### 第一阶段：基础 Hooks（专注完成验证）
1. 实现 Stop hook - 仅在 Claude 完成任务时验证
2. PostToolUse hooks - 快速语法检查
3. UserPromptSubmit - 记录用户意图

### 第二阶段：智能验证
1. Stop hook 中根据任务类型选择验证策略
2. 构建"完成标准"库（什么算真正完成）
3. 智能判断是否需要深度验证

### 第三阶段：用户意图学习
1. 分析 UserPromptSubmit 日志理解用户模式
2. ESC 后的新指令分析（用户为什么中断）
3. 优化验证策略，减少不必要的检查

---

## 迁移路径

从当前方案迁移到 Hooks 方案：

```bash
# 1. 保留现有代码作为备选
mv lib/session-monitor.js lib/legacy/
mv lib/worker-wrapper.js lib/legacy/

# 2. 创建 Hooks 脚本
mkdir -p .claude/hooks
cat > .claude/hooks/stop.sh << 'EOF'
#!/bin/bash
# Claude 完成任务时的验证
node lib/verify-completion.js "$@"
EOF

cat > .claude/hooks/post-tool.sh << 'EOF'
#!/bin/bash
# 工具使用后的快速检查
node lib/quick-check.js "$@"
EOF

# 3. 配置项目级 Claude hooks
cat > .claude/settings.json << 'EOF'
{
  "hooks": {
    "Stop": ".claude/hooks/stop.sh",
    "PostToolUse": {
      "Write": ".claude/hooks/post-tool.sh",
      "Edit": ".claude/hooks/post-tool.sh"
    },
    "UserPromptSubmit": ".claude/hooks/log-intent.sh"
  }
}
EOF

# 4. 重用现有验证逻辑
# lib/supervisor-verify.js 可以重用：
# - InquiryGenerator (智能提问)
# - TestRunner (测试执行)  
# - ProjectAnalyzer (项目分析)
```

这样可以平滑过渡，保留已有投资的同时获得更好的用户体验。