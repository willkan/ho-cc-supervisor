#!/bin/bash

# supervisor-tmux: 全自动验证修复系统的 tmux 透明代理
# 保持 Claude Code 的所有交互特性，同时实现自动修复

# 配置
TMUX_SESSION="claude-supervised"
ISSUES_FILE="/tmp/claude-issues"
FIX_QUEUE="/tmp/claude-fix-queue"
SUPERVISOR_LOG="/tmp/supervisor.log"
SUPERVISOR_PID_FILE="/tmp/supervisor.pid"
FIX_HISTORY_FILE="/tmp/supervisor-fix-history"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 初始化
setup() {
    # 创建必要的目录和文件
    touch "$SUPERVISOR_LOG" "$FIX_HISTORY_FILE"
    
    # 清理旧的队列文件
    rm -f "$FIX_QUEUE"
    mkfifo "$FIX_QUEUE" 2>/dev/null
    
    echo -e "${GREEN}[$(date '+%H:%M:%S')] Supervisor 初始化完成${NC}" | tee -a "$SUPERVISOR_LOG"
}

# 生成修复命令
generate_fix_command() {
    local issues="$1"
    local fix_command=""
    
    # 根据问题类型生成智能修复指令
    if echo "$issues" | grep -q "TypeError\|ReferenceError"; then
        fix_command="发现 JavaScript 错误，请检查并修复类型错误。确保所有变量都正确定义和初始化。"
    elif echo "$issues" | grep -q "测试失败\|test failed"; then
        fix_command="检测到测试失败。请运行测试套件，分析失败原因并修复所有失败的测试。"
    elif echo "$issues" | grep -q "ESLint\|lint"; then
        fix_command="发现代码规范问题。请运行 npm run lint:fix 自动修复，然后手动处理剩余问题。"
    elif echo "$issues" | grep -q "TypeScript\|类型错误"; then
        fix_command="TypeScript 编译错误。请运行 npm run typecheck 并修复所有类型错误。"
    elif echo "$issues" | grep -q "构建失败\|build failed"; then
        fix_command="构建失败。请检查构建日志，修复错误后重新运行 npm run build。"
    else
        # 通用修复指令 - 提取关键信息
        local key_info=$(echo "$issues" | head -3)
        fix_command="检测到问题需要修复：${key_info}。请分析问题原因并进行修复，确保所有测试通过。"
    fi
    
    echo "$fix_command"
}

# 检查是否应该修复（防止死循环）
should_fix() {
    local issue_hash=$(echo "$1" | md5sum | cut -d' ' -f1)
    local current_time=$(date +%s)
    
    # 检查修复历史
    if grep -q "$issue_hash" "$FIX_HISTORY_FILE" 2>/dev/null; then
        local last_fix_time=$(grep "$issue_hash" "$FIX_HISTORY_FILE" | cut -d':' -f2)
        local time_diff=$((current_time - last_fix_time))
        
        # 5分钟内不重复修复同一问题
        if [ $time_diff -lt 300 ]; then
            echo -e "${YELLOW}[$(date '+%H:%M:%S')] 跳过重复问题（5分钟内已尝试修复）${NC}" | tee -a "$SUPERVISOR_LOG"
            return 1
        fi
    fi
    
    # 记录修复历史
    echo "$issue_hash:$current_time" >> "$FIX_HISTORY_FILE"
    
    # 只保留最近100条记录
    tail -100 "$FIX_HISTORY_FILE" > "$FIX_HISTORY_FILE.tmp"
    mv "$FIX_HISTORY_FILE.tmp" "$FIX_HISTORY_FILE"
    
    return 0
}

# 等待 Claude 空闲
wait_for_idle() {
    local max_wait=30
    local waited=0
    
    echo -e "${YELLOW}[$(date '+%H:%M:%S')] 等待 Claude 空闲...${NC}" | tee -a "$SUPERVISOR_LOG"
    
    while [ $waited -lt $max_wait ]; do
        # 捕获 pane 的最后几行
        local last_lines=$(tmux capture-pane -t "$TMUX_SESSION" -p 2>/dev/null | tail -5)
        
        # 检查是否包含提示符或已完成标记
        if echo "$last_lines" | grep -qE '\$|>|Human:|Assistant:|✓|✅|完成|Done'; then
            echo -e "${GREEN}[$(date '+%H:%M:%S')] Claude 已空闲，准备注入命令${NC}" | tee -a "$SUPERVISOR_LOG"
            return 0
        fi
        
        sleep 1
        ((waited++))
    done
    
    echo -e "${YELLOW}[$(date '+%H:%M:%S')] 等待超时，强制注入${NC}" | tee -a "$SUPERVISOR_LOG"
    return 0
}

# 注入修复命令
inject_fix_command() {
    local fix_command="$1"
    
    # 等待合适的时机
    wait_for_idle
    
    # 添加标记以便识别这是自动修复
    local marked_command="[🤖 自动修复] $fix_command"
    
    echo -e "${GREEN}[$(date '+%H:%M:%S')] 注入修复命令: $fix_command${NC}" | tee -a "$SUPERVISOR_LOG"
    
    # 通过 tmux 发送命令
    tmux send-keys -t "$TMUX_SESSION" "$marked_command" Enter
    
    return 0
}

# Supervisor 监控进程
supervisor_monitor() {
    echo -e "${GREEN}[$(date '+%H:%M:%S')] Supervisor 监控启动${NC}" | tee -a "$SUPERVISOR_LOG"
    
    while true; do
        # 检查问题文件
        if [ -f "$ISSUES_FILE" ]; then
            echo -e "${YELLOW}[$(date '+%H:%M:%S')] 发现新问题！${NC}" | tee -a "$SUPERVISOR_LOG"
            
            local issues=$(cat "$ISSUES_FILE")
            
            # 检查是否应该修复
            if should_fix "$issues"; then
                # 生成修复命令
                local fix_command=$(generate_fix_command "$issues")
                
                # 注入修复命令
                inject_fix_command "$fix_command"
                
                echo -e "${GREEN}[$(date '+%H:%M:%S')] 修复命令已注入${NC}" | tee -a "$SUPERVISOR_LOG"
            fi
            
            # 清理问题文件
            rm -f "$ISSUES_FILE"
        fi
        
        # 短暂休眠避免 CPU 占用
        sleep 0.5
    done
}

# 清理函数
cleanup() {
    echo -e "${YELLOW}[$(date '+%H:%M:%S')] 正在清理...${NC}"
    
    # 终止 supervisor 进程
    if [ -f "$SUPERVISOR_PID_FILE" ]; then
        local pid=$(cat "$SUPERVISOR_PID_FILE")
        kill $pid 2>/dev/null
        rm -f "$SUPERVISOR_PID_FILE"
    fi
    
    # 清理临时文件
    rm -f "$FIX_QUEUE" "$ISSUES_FILE"
    
    echo -e "${GREEN}[$(date '+%H:%M:%S')] 清理完成${NC}"
}

# 主函数
main() {
    # 设置信号处理
    trap cleanup EXIT INT TERM
    
    # 初始化
    setup
    
    # 检查 tmux 是否安装
    if ! command -v tmux &> /dev/null; then
        echo -e "${RED}错误: tmux 未安装。请先安装 tmux:${NC}"
        echo "  macOS: brew install tmux"
        echo "  Linux: apt-get install tmux 或 yum install tmux"
        exit 1
    fi
    
    # 检查会话是否已存在
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo -e "${YELLOW}检测到已有 supervised Claude 会话${NC}"
        
        # 检查 supervisor 是否在运行
        if [ ! -f "$SUPERVISOR_PID_FILE" ] || ! kill -0 $(cat "$SUPERVISOR_PID_FILE" 2>/dev/null) 2>/dev/null; then
            echo -e "${YELLOW}重启 Supervisor 监控...${NC}"
            supervisor_monitor &
            echo $! > "$SUPERVISOR_PID_FILE"
        fi
    else
        echo -e "${GREEN}创建新的 supervised Claude 会话${NC}"
        
        # 创建 tmux 会话并运行 Claude
        tmux new-session -d -s "$TMUX_SESSION" "claude"
        
        # 等待会话创建
        sleep 1
        
        # 启动 supervisor 监控
        supervisor_monitor &
        echo $! > "$SUPERVISOR_PID_FILE"
        
        echo -e "${GREEN}Supervisor 已启动 (PID: $!)${NC}"
    fi
    
    # 附加到 tmux 会话
    echo -e "${GREEN}连接到 supervised Claude 会话...${NC}"
    echo -e "${YELLOW}提示: 使用 Ctrl+B D 分离会话，会话将在后台继续运行${NC}"
    
    tmux attach-session -t "$TMUX_SESSION"
}

# 显示帮助
show_help() {
    cat << EOF
Supervisor-Tmux: Claude Code 全自动验证修复系统

使用方法:
    supervisor-tmux           # 启动 supervised Claude
    supervisor-tmux status    # 查看运行状态
    supervisor-tmux stop      # 停止所有组件
    supervisor-tmux logs      # 查看 supervisor 日志
    supervisor-tmux help      # 显示此帮助

特性:
    - 保持 Claude Code 的所有原生交互特性
    - 自动检测并修复代码问题
    - 防止死循环的智能重试机制
    - 完全透明的用户体验

EOF
}

# 命令行参数处理
case "${1:-}" in
    status)
        if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
            echo -e "${GREEN}✓ Claude session 运行中${NC}"
        else
            echo -e "${RED}✗ Claude session 未运行${NC}"
        fi
        
        if [ -f "$SUPERVISOR_PID_FILE" ] && kill -0 $(cat "$SUPERVISOR_PID_FILE" 2>/dev/null) 2>/dev/null; then
            echo -e "${GREEN}✓ Supervisor 运行中 (PID: $(cat $SUPERVISOR_PID_FILE))${NC}"
        else
            echo -e "${RED}✗ Supervisor 未运行${NC}"
        fi
        ;;
        
    stop)
        echo "停止 Supervisor-Tmux..."
        cleanup
        tmux kill-session -t "$TMUX_SESSION" 2>/dev/null
        echo -e "${GREEN}已停止${NC}"
        ;;
        
    logs)
        if [ -f "$SUPERVISOR_LOG" ]; then
            tail -f "$SUPERVISOR_LOG"
        else
            echo "没有日志文件"
        fi
        ;;
        
    help|--help|-h)
        show_help
        ;;
        
    "")
        main
        ;;
        
    *)
        echo -e "${RED}未知命令: $1${NC}"
        show_help
        exit 1
        ;;
esac