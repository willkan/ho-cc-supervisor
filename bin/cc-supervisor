#!/usr/bin/env node

/**
 * CC-Supervisor - Claudeæ™ºèƒ½ç›‘å·¥
 * æç®€CLIï¼Œæ”¯æŒå›½é™…åŒ–
 */

const { program } = require('commander');
const path = require('path');
const fs = require('fs');
const { execSync } = require('child_process');
const readline = require('readline');

// åŠ è½½è¯­è¨€åŒ…
let i18n = {};

// åŠ è½½è¯­è¨€æ–‡ä»¶
function loadLocale(lang) {
  const localePath = path.join(__dirname, '..', 'locales', `${lang}.json`);
  if (fs.existsSync(localePath)) {
    i18n = JSON.parse(fs.readFileSync(localePath, 'utf-8'));
    return true;
  }
  return false;
}

// è·å–ç¿»è¯‘æ–‡æœ¬
function t(key, replacements = {}) {
  const keys = key.split('.');
  let value = i18n;
  for (const k of keys) {
    value = value?.[k];
    if (!value) return key; // å¦‚æœæ‰¾ä¸åˆ°ç¿»è¯‘ï¼Œè¿”å›é”®å
  }
  // æ›¿æ¢å ä½ç¬¦
  let result = value;
  for (const [placeholder, replacement] of Object.entries(replacements)) {
    result = result.replace(`{${placeholder}}`, replacement);
  }
  return result;
}

// è¯¢é—®ç”¨æˆ·é€‰æ‹©
function askQuestion(query) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise(resolve => rl.question(query, ans => {
    rl.close();
    resolve(ans);
  }));
}

// æ£€æŸ¥å¹¶åŠ è½½ä¿å­˜çš„è¯­è¨€åå¥½
function loadSavedLocale() {
  const configPath = path.join('.claude', 'cc-supervisor-config.json');
  if (fs.existsSync(configPath)) {
    try {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      if (config.locale && loadLocale(config.locale)) {
        return true;
      }
    } catch (err) {
      // é…ç½®æ–‡ä»¶å¯èƒ½æŸåï¼Œå¿½ç•¥
    }
  }
  
  // å°è¯•ä»ç¯å¢ƒå˜é‡åŠ è½½
  const envLang = process.env.LANG || process.env.LANGUAGE || '';
  if (envLang.includes('zh') || envLang.includes('CN')) {
    loadLocale('zh-CN');
  } else {
    loadLocale('en-US');
  }
  return false;
}

// åˆå§‹åŠ è½½é»˜è®¤è¯­è¨€
loadSavedLocale();

// è®¾ç½®ç‰ˆæœ¬å’Œæè¿°
program
  .name('cc-supervisor')
  .description(t('cli.description'))
  .version(t('cli.version'));

// init å‘½ä»¤ - åˆå§‹åŒ–ç›‘å·¥ç³»ç»Ÿ
program
  .command('init')
  .description(t('cli.commands.init.description'))
  .option('--lang <language>', 'Set language (zh-CN or en-US)')
  .action(async (options) => {
    // å¦‚æœæ²¡æœ‰æŒ‡å®šè¯­è¨€ï¼Œè¯¢é—®ç”¨æˆ·
    let selectedLang = options.lang;
    if (!selectedLang) {
      console.log(t('cli.commands.init.selectLanguage'));
      console.log('  1) ä¸­æ–‡');
      console.log('  2) English');
      const answer = await askQuestion('Please choose (1 or 2): ');
      selectedLang = answer === '2' ? 'en-US' : 'zh-CN';
    }
    
    // åŠ è½½é€‰æ‹©çš„è¯­è¨€
    if (!loadLocale(selectedLang)) {
      console.error(`Language ${selectedLang} not supported, using default`);
      selectedLang = 'zh-CN';
      loadLocale(selectedLang);
    }
    
    console.log(t('cli.commands.init.initializing'));
    
    try {
      // åˆ›å»º .claude ç›®å½•
      const claudeDir = '.claude';
      const hooksDir = path.join(claudeDir, 'hooks');
      
      if (!fs.existsSync(claudeDir)) {
        fs.mkdirSync(claudeDir, { recursive: true });
      }
      
      if (!fs.existsSync(hooksDir)) {
        fs.mkdirSync(hooksDir, { recursive: true });
      }

      // å¤åˆ¶ç›‘å·¥Hookè„šæœ¬ï¼ˆä»templatesç›®å½•ï¼‰
      const packageRoot = path.join(__dirname, '..');
      const sourceHook = path.join(packageRoot, 'templates', 'hooks', 'cc-supervisor-stop.sh');
      
      // æ ¹æ®è¯­è¨€é€‰æ‹©è§„åˆ™æ–‡ä»¶
      const rulesFile = selectedLang === 'en-US' ? 'cc-supervisor-rules.en.txt' : 'cc-supervisor-rules.txt';
      const sourceRules = path.join(packageRoot, 'templates', rulesFile);
      
      // ä½¿ç”¨æ›´å…·ä½“çš„æ–‡ä»¶åé¿å…å†²çª
      const targetHook = path.join(hooksDir, 'cc-supervisor-stop.sh');
      const targetRules = path.join(claudeDir, 'cc-supervisor-rules.txt');
      const targetConfig = path.join(claudeDir, 'cc-supervisor-config.json');

      if (fs.existsSync(sourceHook)) {
        fs.copyFileSync(sourceHook, targetHook);
        fs.chmodSync(targetHook, 0o755);
        console.log(t('cli.commands.init.hookInstalled'));
      }

      if (fs.existsSync(sourceRules)) {
        if (!fs.existsSync(targetRules)) {
          fs.copyFileSync(sourceRules, targetRules);
          console.log(t('cli.commands.init.rulesInstalled'));
        } else {
          console.log(t('cli.commands.init.rulesPreserved'));
        }
      }

      // æ›´æ–°é…ç½®æ–‡ä»¶ï¼Œä¿å­˜è¯­è¨€åå¥½
      let config = {};
      if (fs.existsSync(targetConfig)) {
        try {
          config = JSON.parse(fs.readFileSync(targetConfig, 'utf-8'));
        } catch (err) {
          // é…ç½®æ–‡ä»¶æŸåï¼Œä½¿ç”¨é»˜è®¤é…ç½®
        }
      }
      
      // ä¿å­˜è¯­è¨€åå¥½
      config.locale = selectedLang;
      if (!config.claude_command) {
        config.claude_command = {
          base: "claude",
          args: ["-p"]
        };
      }
      
      fs.writeFileSync(targetConfig, JSON.stringify(config, null, 2));
      console.log(t('cli.commands.init.configInstalled'));

      // æ›´æ–°æˆ–åˆ›å»º settings.json
      const settingsPath = path.join(claudeDir, 'settings.json');
      let settings = { hooks: {} };
      
      if (fs.existsSync(settingsPath)) {
        try {
          settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        } catch (err) {
          console.log(t('cli.commands.init.settingsError'));
        }
      }

      // é…ç½®Stop Hook (å®˜æ–¹æ ¼å¼) - 20åˆ†é’Ÿè¶…æ—¶
      // ä¿ç•™ç°æœ‰çš„Stop hooksï¼Œæ·»åŠ æˆ‘ä»¬çš„
      if (!settings.hooks) {
        settings.hooks = {};
      }
      if (!settings.hooks.Stop) {
        settings.hooks.Stop = [];
      }
      
      // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æˆ‘ä»¬çš„hook
      const ourHookCommand = "$CLAUDE_PROJECT_DIR/.claude/hooks/cc-supervisor-stop.sh";
      let hasOurHook = false;
      
      for (const stopConfig of settings.hooks.Stop) {
        if (stopConfig.hooks) {
          for (const hook of stopConfig.hooks) {
            if (hook.command === ourHookCommand) {
              hasOurHook = true;
              // æ›´æ–°è¶…æ—¶æ—¶é—´
              hook.timeout = 1200;
              break;
            }
          }
        }
      }
      
      // å¦‚æœæ²¡æœ‰æˆ‘ä»¬çš„hookï¼Œæ·»åŠ å®ƒ
      if (!hasOurHook) {
        settings.hooks.Stop.push({
          "hooks": [{
            "type": "command",
            "command": ourHookCommand,
            "timeout": 1200
          }]
        });
      }

      fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
      console.log(t('cli.commands.init.settingsUpdated'));

      console.log('');
      console.log(t('cli.commands.init.complete'));
      console.log('');
      console.log(t('cli.commands.init.usage'));
      console.log(t('cli.commands.init.usage1'));
      console.log(t('cli.commands.init.usage2'));
      console.log(t('cli.commands.init.usage3'));
      console.log(t('cli.commands.init.usage4'));
      console.log(t('cli.commands.init.usage5'));

    } catch (err) {
      console.error(t('cli.commands.init.error'), err.message);
      process.exit(1);
    }
  });

// logs å‘½ä»¤ - æŸ¥çœ‹è°ƒè¯•æ—¥å¿—
program
  .command('logs')
  .description(t('cli.commands.logs.description'))
  .option('-f, --follow', t('cli.commands.logs.followOption'))
  .option('-w, --watch', t('cli.commands.logs.watchOption'))
  .option('-n, --lines <number>', t('cli.commands.logs.linesOption'), '20')
  .option('--session <id>', t('cli.commands.logs.sessionOption'))
  .option('--list', t('cli.commands.logs.listOption'))
  .action(async (options) => {
    console.log(t('cli.commands.logs.viewing'));
    
    const projectDir = process.cwd();
    const projectName = projectDir.replace(/\//g, '-');
    const logsBaseDir = `/tmp/cc-supervisor/${projectName}`;
    
    // åˆ—å‡ºæ‰€æœ‰æ—¥å¿—
    if (options.list) {
      try {
        if (!fs.existsSync(logsBaseDir)) {
          console.log(t('cli.commands.logs.noLogs'));
          return;
        }
        
        const sessions = fs.readdirSync(logsBaseDir);
        if (sessions.length === 0) {
          console.log(t('cli.commands.logs.noSessions'));
          return;
        }
        
        console.log(t('cli.commands.logs.availableSessions'));
        sessions.forEach(session => {
          const debugLog = path.join(logsBaseDir, session, 'debug.log');
          if (fs.existsSync(debugLog)) {
            const stats = fs.statSync(debugLog);
            console.log(`  ğŸ“ ${session}`);
            console.log(`     ${t('cli.commands.logs.createdAt')} ${stats.birthtime.toLocaleString()}`);
            console.log(`     ${t('cli.commands.logs.fileSize')} ${(stats.size / 1024).toFixed(2)} KB`);
          }
        });
        return;
      } catch (err) {
        console.error(t('cli.commands.logs.readError'), err.message);
        return;
      }
    }
    
    // æŸ¥çœ‹ç‰¹å®šsessionæˆ–æœ€æ–°çš„æ—¥å¿—
    let targetLog;
    
    if (options.session) {
      targetLog = path.join(logsBaseDir, options.session, 'debug.log');
    } else {
      // æ‰¾æœ€æ–°çš„æ—¥å¿—
      try {
        if (!fs.existsSync(logsBaseDir)) {
          console.log(t('cli.commands.logs.noLogs'));
          console.log(t('cli.commands.logs.generatedTip'));
          return;
        }
        
        const sessions = fs.readdirSync(logsBaseDir)
          .map(name => ({
            name,
            path: path.join(logsBaseDir, name, 'debug.log'),
            time: fs.existsSync(path.join(logsBaseDir, name, 'debug.log')) 
              ? fs.statSync(path.join(logsBaseDir, name, 'debug.log')).mtime 
              : 0
          }))
          .filter(s => s.time > 0)
          .sort((a, b) => b.time - a.time);
        
        if (sessions.length === 0) {
          console.log(t('cli.commands.logs.noDebugLogs'));
          return;
        }
        
        targetLog = sessions[0].path;
        console.log(t('cli.commands.logs.viewingLatest'), sessions[0].name);
      } catch (err) {
        console.error(t('cli.commands.logs.findError'), err.message);
        return;
      }
    }
    
    // æ£€æŸ¥æ—¥å¿—æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if (!fs.existsSync(targetLog)) {
      console.log(t('cli.commands.logs.fileNotExist'), targetLog);
      return;
    }
    
    // æ˜¾ç¤ºæ—¥å¿—å†…å®¹
    if (options.watch) {
      // ç›‘æ§æ¨¡å¼ï¼šç­‰å¾…æ–°çš„session
      console.log(t('cli.commands.logs.waitingSession'));
      console.log(t('cli.commands.logs.monitoringDir'), logsBaseDir + '\n');
      
      const startTime = Date.now();
      let currentTail = null;
      let monitoredLog = null;
      
      // ç›‘æ§ç›®å½•ï¼Œæ‰¾åˆ°æ–°çš„æˆ–æ›´æ–°çš„debug.log
      const checkForLogs = () => {
        if (!fs.existsSync(logsBaseDir)) {
          // ç›®å½•è¿˜ä¸å­˜åœ¨ï¼Œç»§ç»­ç­‰å¾…
          setTimeout(checkForLogs, 1000);
          return;
        }
        
        // éå†æ‰€æœ‰sessionæŸ¥æ‰¾debug.log
        const sessions = fs.readdirSync(logsBaseDir);
        for (const session of sessions) {
          const debugLog = path.join(logsBaseDir, session, 'debug.log');
          
          if (fs.existsSync(debugLog)) {
            const stats = fs.statSync(debugLog);
            // æ£€æŸ¥æ–‡ä»¶ä¿®æ”¹æ—¶é—´æ˜¯å¦åœ¨ç›‘æ§å¼€å§‹ä¹‹å
            if (stats.mtimeMs > startTime && debugLog !== monitoredLog) {
              console.log(t('cli.commands.logs.foundActive'), session);
              console.log(t('cli.commands.logs.startTracking'), debugLog + '\n');
              
              // å¦‚æœå·²æœ‰tailè¿›ç¨‹ï¼Œå…ˆåœæ­¢
              if (currentTail) {
                currentTail.kill();
              }
              
              monitoredLog = debugLog;
              
              // å¼€å§‹tail -f
              const { spawn } = require('child_process');
              currentTail = spawn('tail', ['-f', debugLog]);
              
              currentTail.stdout.on('data', (data) => {
                process.stdout.write(data);
              });
              
              currentTail.stderr.on('data', (data) => {
                console.error(`Error: ${data}`);
              });
              
              currentTail.on('close', (code) => {
                if (code !== 0 && code !== null) {
                  console.log(t('cli.commands.logs.tailExited'), code);
                }
                currentTail = null;
              });
              
              return; // æ‰¾åˆ°ååœæ­¢è¿™æ¬¡æ£€æŸ¥
            }
          }
        }
        
        // ç»§ç»­æ£€æŸ¥
        setTimeout(checkForLogs, 1000);
      };
      
      checkForLogs();
      
      // å¤„ç†Ctrl+C
      process.on('SIGINT', () => {
        if (currentTail) {
          currentTail.kill();
        }
        console.log(t('cli.commands.logs.stopMonitor'));
        process.exit(0);
      });
      
      return; // é˜»æ­¢æ‰§è¡Œåç»­ä»£ç 
    } else if (options.follow) {
      // ä¼ ç»Ÿçš„ tail -f æ¨¡å¼ï¼šè·Ÿè¸ªç°æœ‰æ—¥å¿—
      console.log(t('cli.commands.logs.realTimeTracking'));
      const { spawn } = require('child_process');
      const tail = spawn('tail', ['-f', targetLog]);
      
      tail.stdout.on('data', (data) => {
        process.stdout.write(data);
      });
      
      tail.stderr.on('data', (data) => {
        console.error(`Error: ${data}`);
      });
      
      tail.on('close', (code) => {
        if (code !== 0) {
          console.log(t('cli.commands.logs.tailExited'), code);
        }
      });
      
      // å¤„ç†Ctrl+C
      process.on('SIGINT', () => {
        tail.kill();
        console.log(t('cli.commands.logs.stopTracking'));
        process.exit(0);
      });
      
      return;
    } else {
      // æ˜¾ç¤ºæœ€åNè¡Œ
      try {
        const content = fs.readFileSync(targetLog, 'utf-8');
        const lines = content.split('\n');
        const lastLines = lines.slice(-parseInt(options.lines) - 1).join('\n');
        
        console.log('');
        console.log('â”€'.repeat(60));
        console.log(lastLines);
        console.log('â”€'.repeat(60));
        console.log(t('cli.commands.logs.logLocation'), targetLog);
        console.log(t('cli.commands.logs.useTailTip'));
      } catch (err) {
        console.error(t('cli.commands.logs.readFileError'), err.message);
      }
    }
  });

// clean å‘½ä»¤ - æ¸…ç†æ—¥å¿—
program
  .command('clean')
  .description(t('cli.commands.clean.description'))
  .option('--all', t('cli.commands.clean.allOption'))
  .option('--days <number>', t('cli.commands.clean.daysOption'), '7')
  .action(async (options) => {
    console.log(t('cli.commands.clean.cleaning'));
    
    const projectDir = process.cwd();
    const projectName = projectDir.replace(/\//g, '-');
    const logsBaseDir = options.all ? '/tmp/cc-supervisor' : `/tmp/cc-supervisor/${projectName}`;
    
    if (!fs.existsSync(logsBaseDir)) {
      console.log(t('cli.commands.clean.noNeedClean'));
      return;
    }
    
    try {
      const days = parseInt(options.days);
      const cutoffTime = Date.now() - (days * 24 * 60 * 60 * 1000);
      let cleanedCount = 0;
      
      // é€’å½’æ¸…ç†æ—§æ—¥å¿—
      const cleanDir = (dir) => {
        const items = fs.readdirSync(dir);
        items.forEach(item => {
          const itemPath = path.join(dir, item);
          const stats = fs.statSync(itemPath);
          
          if (stats.isDirectory()) {
            // æ£€æŸ¥ç›®å½•æ—¶é—´
            if (stats.mtime.getTime() < cutoffTime) {
              fs.rmSync(itemPath, { recursive: true, force: true });
              cleanedCount++;
              console.log(`  ${t('cli.commands.clean.deleted')} ${item}`);
            } else if (options.all) {
              cleanDir(itemPath); // é€’å½’æ¸…ç†å­ç›®å½•
            }
          }
        });
      };
      
      cleanDir(logsBaseDir);
      
      if (cleanedCount > 0) {
        console.log(t('cli.commands.clean.cleanedCount', { count: cleanedCount }));
      } else {
        console.log(t('cli.commands.clean.noOldLogs'));
      }
      
    } catch (err) {
      console.error(t('cli.commands.clean.error'), err.message);
    }
  });

// pause å‘½ä»¤ - æš‚åœç›‘å·¥
program
  .command('pause')
  .description(t('cli.commands.pause.description'))
  .action(async () => {
    try {
      const configPath = path.join(process.cwd(), '.claude', 'cc-supervisor-config.json');
      
      // æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(configPath)) {
        console.error(t('cli.commands.pause.notInitialized'));
        process.exit(1);
      }
      
      // è¯»å–ç°æœ‰é…ç½®
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      
      // è®¾ç½®æš‚åœçŠ¶æ€
      config.paused = true;
      config.pausedAt = new Date().toISOString();
      
      // å†™å›é…ç½®æ–‡ä»¶
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
      
      console.log(t('cli.commands.pause.success'));
      console.log(t('cli.commands.pause.reminder'));
      
    } catch (err) {
      console.error(t('cli.commands.pause.error'), err.message);
      process.exit(1);
    }
  });

// resume å‘½ä»¤ - æ¢å¤ç›‘å·¥
program
  .command('resume')
  .description(t('cli.commands.resume.description'))
  .action(async () => {
    try {
      const configPath = path.join(process.cwd(), '.claude', 'cc-supervisor-config.json');
      
      // æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(configPath)) {
        console.error(t('cli.commands.resume.notInitialized'));
        process.exit(1);
      }
      
      // è¯»å–ç°æœ‰é…ç½®
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      
      // æ£€æŸ¥æ˜¯å¦å·²æš‚åœ
      if (!config.paused) {
        console.log(t('cli.commands.resume.notPaused'));
        return;
      }
      
      // æ¸…é™¤æš‚åœçŠ¶æ€
      delete config.paused;
      delete config.pausedAt;
      
      // å†™å›é…ç½®æ–‡ä»¶
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
      
      console.log(t('cli.commands.resume.success'));
      
    } catch (err) {
      console.error(t('cli.commands.resume.error'), err.message);
      process.exit(1);
    }
  });

// status å‘½ä»¤ - æŸ¥çœ‹ç›‘å·¥çŠ¶æ€
program
  .command('status')
  .description(t('cli.commands.status.description'))
  .action(async () => {
    try {
      const configPath = path.join(process.cwd(), '.claude', 'cc-supervisor-config.json');
      
      // æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(configPath)) {
        console.error(t('cli.commands.status.notInitialized'));
        process.exit(1);
      }
      
      // è¯»å–é…ç½®
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      
      if (config.paused) {
        const pausedAt = new Date(config.pausedAt);
        const duration = Math.floor((Date.now() - pausedAt) / 1000 / 60); // åˆ†é’Ÿ
        console.log(t('cli.commands.status.paused', { duration, time: pausedAt.toLocaleString() }));
      } else {
        console.log(t('cli.commands.status.active'));
      }
      
      // æ˜¾ç¤ºå…¶ä»–é…ç½®ä¿¡æ¯
      console.log(t('cli.commands.status.locale', { locale: config.locale || 'zh-CN' }));
      if (config.claude_command) {
        const cmd = `${config.claude_command.base} ${(config.claude_command.args || []).join(' ')}`.trim();
        console.log(t('cli.commands.status.command', { command: cmd }));
      }
      
    } catch (err) {
      console.error(t('cli.commands.status.error'), err.message);
      process.exit(1);
    }
  });

// è§£æå‘½ä»¤è¡Œå‚æ•°
program.parse();

// å¦‚æœæ²¡æœ‰æä¾›å‘½ä»¤ï¼Œæ˜¾ç¤ºå¸®åŠ©
if (!process.argv.slice(2).length) {
  program.outputHelp();
}