#!/usr/bin/env node

/**
 * CC-Supervisor - Claudeæ™ºèƒ½ç›‘å·¥
 * æç®€CLIï¼Œåªæä¾›åˆå§‹åŒ–åŠŸèƒ½
 */

const { program } = require('commander');
const path = require('path');
const fs = require('fs');
const { execSync } = require('child_process');

// è®¾ç½®ç‰ˆæœ¬å’Œæè¿°
program
  .name('cc-supervisor')
  .description('Claudeæ™ºèƒ½ç›‘å·¥ - é˜²æ­¢Claudeå·æ‡’çš„æç®€Hookç³»ç»Ÿ')
  .version('3.0.0');

// init å‘½ä»¤ - åˆå§‹åŒ–ç›‘å·¥ç³»ç»Ÿ
program
  .command('init')
  .description('åˆå§‹åŒ–Claudeç›‘å·¥ç³»ç»Ÿ')
  .action(async () => {
    console.log('ğŸš€ åˆå§‹åŒ– Claude æ™ºèƒ½ç›‘å·¥...');
    
    try {
      // åˆ›å»º .claude ç›®å½•
      const claudeDir = '.claude';
      const hooksDir = path.join(claudeDir, 'hooks');
      
      if (!fs.existsSync(claudeDir)) {
        fs.mkdirSync(claudeDir, { recursive: true });
      }
      
      if (!fs.existsSync(hooksDir)) {
        fs.mkdirSync(hooksDir, { recursive: true });
      }

      // å¤åˆ¶ç›‘å·¥Hookè„šæœ¬ï¼ˆä»templatesç›®å½•ï¼‰
      const packageRoot = path.join(__dirname, '..');
      const sourceHook = path.join(packageRoot, 'templates', 'hooks', 'cc-supervisor-stop.sh');
      const sourceRules = path.join(packageRoot, 'templates', 'cc-supervisor-rules.txt');
      const sourceConfig = path.join(packageRoot, 'templates', 'cc-supervisor-config.json');
      
      // ä½¿ç”¨æ›´å…·ä½“çš„æ–‡ä»¶åé¿å…å†²çª
      const targetHook = path.join(hooksDir, 'cc-supervisor-stop.sh');
      const targetRules = path.join(claudeDir, 'cc-supervisor-rules.txt');
      const targetConfig = path.join(claudeDir, 'cc-supervisor-config.json');

      if (fs.existsSync(sourceHook)) {
        fs.copyFileSync(sourceHook, targetHook);
        fs.chmodSync(targetHook, 0o755);
        console.log('ğŸ“„ ç›‘å·¥Hookå·²å®‰è£…');
      }

      if (fs.existsSync(sourceRules)) {
        if (!fs.existsSync(targetRules)) {
          fs.copyFileSync(sourceRules, targetRules);
          console.log('ğŸ“‹ é»˜è®¤ç›‘å·¥è§„åˆ™å·²å®‰è£…');
        } else {
          console.log('â­ï¸ ä¿ç•™ç°æœ‰ç›‘å·¥è§„åˆ™');
        }
      }

      if (fs.existsSync(sourceConfig)) {
        if (!fs.existsSync(targetConfig)) {
          fs.copyFileSync(sourceConfig, targetConfig);
          console.log('âš™ï¸ ç›‘å·¥é…ç½®æ–‡ä»¶å·²å®‰è£…');
        } else {
          console.log('â­ï¸ ä¿ç•™ç°æœ‰ç›‘å·¥é…ç½®');
        }
      }

      // æ›´æ–°æˆ–åˆ›å»º settings.json
      const settingsPath = path.join(claudeDir, 'settings.json');
      let settings = { hooks: {} };
      
      if (fs.existsSync(settingsPath)) {
        try {
          settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        } catch (err) {
          console.log('âš ï¸ ç°æœ‰settings.jsonæ ¼å¼é”™è¯¯ï¼Œå°†åˆ›å»ºæ–°çš„');
        }
      }

      // é…ç½®Stop Hook (å®˜æ–¹æ ¼å¼) - 20åˆ†é’Ÿè¶…æ—¶
      // ä¿ç•™ç°æœ‰çš„Stop hooksï¼Œæ·»åŠ æˆ‘ä»¬çš„
      if (!settings.hooks) {
        settings.hooks = {};
      }
      if (!settings.hooks.Stop) {
        settings.hooks.Stop = [];
      }
      
      // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æˆ‘ä»¬çš„hook
      const ourHookCommand = "$CLAUDE_PROJECT_DIR/.claude/hooks/cc-supervisor-stop.sh";
      let hasOurHook = false;
      
      for (const stopConfig of settings.hooks.Stop) {
        if (stopConfig.hooks) {
          for (const hook of stopConfig.hooks) {
            if (hook.command === ourHookCommand) {
              hasOurHook = true;
              // æ›´æ–°è¶…æ—¶æ—¶é—´
              hook.timeout = 1200;
              break;
            }
          }
        }
      }
      
      // å¦‚æœæ²¡æœ‰æˆ‘ä»¬çš„hookï¼Œæ·»åŠ å®ƒ
      if (!hasOurHook) {
        settings.hooks.Stop.push({
          "hooks": [{
            "type": "command",
            "command": ourHookCommand,
            "timeout": 1200
          }]
        });
      }

      fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
      console.log('âš™ï¸ Claude Code settingså·²æ›´æ–°');

      console.log('');
      console.log('âœ… Claudeæ™ºèƒ½ç›‘å·¥åˆå§‹åŒ–å®Œæˆï¼');
      console.log('');
      console.log('ğŸ“– ä½¿ç”¨è¯´æ˜:');
      console.log('1. å¯åŠ¨Claude Codeæ­£å¸¸å·¥ä½œ');
      console.log('2. ç›‘å·¥ä¼šè‡ªåŠ¨æ£€æŸ¥Claudeçš„å·¥ä½œè´¨é‡');
      console.log('3. å‘ç°å·æ‡’è¡Œä¸ºæ—¶ä¼šè‡ªåŠ¨è¦æ±‚é‡åš');
      console.log('4. å¯ç¼–è¾‘ .claude/cc-supervisor-rules.txt è‡ªå®šä¹‰ç›‘å·¥è§„åˆ™');
      console.log('5. å¯ç¼–è¾‘ .claude/cc-supervisor-config.json é…ç½®Claudeå‘½ä»¤å‚æ•°');

    } catch (err) {
      console.error('âŒ åˆå§‹åŒ–å¤±è´¥:', err.message);
      process.exit(1);
    }
  });

// logs å‘½ä»¤ - æŸ¥çœ‹è°ƒè¯•æ—¥å¿—
program
  .command('logs')
  .description('æŸ¥çœ‹ç›‘å·¥ç³»ç»Ÿçš„è°ƒè¯•æ—¥å¿—')
  .option('-f, --follow', 'å®æ—¶è·Ÿè¸ªæœ€æ–°çš„ç°æœ‰æ—¥å¿— (tail -f)')
  .option('-w, --watch', 'ç­‰å¾…å¹¶ç›‘æ§æ–°çš„ç›‘å·¥session')
  .option('-n, --lines <number>', 'æ˜¾ç¤ºæœ€åNè¡Œæ—¥å¿—', '20')
  .option('--session <id>', 'æŸ¥çœ‹ç‰¹å®šsessionçš„æ—¥å¿—')
  .option('--list', 'åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„æ—¥å¿—æ–‡ä»¶')
  .action(async (options) => {
    console.log('ğŸ“‹ æŸ¥çœ‹ç›‘å·¥è°ƒè¯•æ—¥å¿—...');
    
    const projectDir = process.cwd();
    const projectName = projectDir.replace(/\//g, '-');
    const logsBaseDir = `/tmp/cc-supervisor/${projectName}`;
    
    // åˆ—å‡ºæ‰€æœ‰æ—¥å¿—
    if (options.list) {
      try {
        if (!fs.existsSync(logsBaseDir)) {
          console.log('âŒ å½“å‰é¡¹ç›®æ²¡æœ‰è°ƒè¯•æ—¥å¿—');
          return;
        }
        
        const sessions = fs.readdirSync(logsBaseDir);
        if (sessions.length === 0) {
          console.log('âŒ æ²¡æœ‰æ‰¾åˆ°ä»»ä½•sessionæ—¥å¿—');
          return;
        }
        
        console.log('\nå¯ç”¨çš„Sessionæ—¥å¿—:');
        sessions.forEach(session => {
          const debugLog = path.join(logsBaseDir, session, 'debug.log');
          if (fs.existsSync(debugLog)) {
            const stats = fs.statSync(debugLog);
            console.log(`  ğŸ“ ${session}`);
            console.log(`     åˆ›å»ºæ—¶é—´: ${stats.birthtime.toLocaleString()}`);
            console.log(`     æ–‡ä»¶å¤§å°: ${(stats.size / 1024).toFixed(2)} KB`);
          }
        });
        return;
      } catch (err) {
        console.error('âŒ è¯»å–æ—¥å¿—ç›®å½•å¤±è´¥:', err.message);
        return;
      }
    }
    
    // æŸ¥çœ‹ç‰¹å®šsessionæˆ–æœ€æ–°çš„æ—¥å¿—
    let targetLog;
    
    if (options.session) {
      targetLog = path.join(logsBaseDir, options.session, 'debug.log');
    } else {
      // æ‰¾æœ€æ–°çš„æ—¥å¿—
      try {
        if (!fs.existsSync(logsBaseDir)) {
          console.log('âŒ å½“å‰é¡¹ç›®æ²¡æœ‰è°ƒè¯•æ—¥å¿—');
          console.log('ğŸ’¡ æç¤º: è°ƒè¯•æ—¥å¿—åœ¨ç›‘å·¥æ£€æŸ¥æ—¶ç”Ÿæˆ');
          return;
        }
        
        const sessions = fs.readdirSync(logsBaseDir)
          .map(name => ({
            name,
            path: path.join(logsBaseDir, name, 'debug.log'),
            time: fs.existsSync(path.join(logsBaseDir, name, 'debug.log')) 
              ? fs.statSync(path.join(logsBaseDir, name, 'debug.log')).mtime 
              : 0
          }))
          .filter(s => s.time > 0)
          .sort((a, b) => b.time - a.time);
        
        if (sessions.length === 0) {
          console.log('âŒ æ²¡æœ‰æ‰¾åˆ°è°ƒè¯•æ—¥å¿—');
          return;
        }
        
        targetLog = sessions[0].path;
        console.log(`ğŸ“‚ æŸ¥çœ‹æœ€æ–°æ—¥å¿—: ${sessions[0].name}`);
      } catch (err) {
        console.error('âŒ æŸ¥æ‰¾æ—¥å¿—å¤±è´¥:', err.message);
        return;
      }
    }
    
    // æ£€æŸ¥æ—¥å¿—æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if (!fs.existsSync(targetLog)) {
      console.log(`âŒ æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨: ${targetLog}`);
      return;
    }
    
    // æ˜¾ç¤ºæ—¥å¿—å†…å®¹
    if (options.watch) {
      // ç›‘æ§æ¨¡å¼ï¼šç­‰å¾…æ–°çš„session
      console.log('ğŸ“¡ ç­‰å¾…æ–°çš„ç›‘å·¥session... (Ctrl+C é€€å‡º)');
      console.log(`ç›‘æ§ç›®å½•: ${logsBaseDir}\n`);
      
      const startTime = Date.now();
      let currentTail = null;
      let monitoredLog = null;
      
      // ç›‘æ§ç›®å½•ï¼Œæ‰¾åˆ°æ–°çš„æˆ–æ›´æ–°çš„debug.log
      const checkForLogs = () => {
        if (!fs.existsSync(logsBaseDir)) {
          // ç›®å½•è¿˜ä¸å­˜åœ¨ï¼Œç»§ç»­ç­‰å¾…
          setTimeout(checkForLogs, 1000);
          return;
        }
        
        // éå†æ‰€æœ‰sessionæŸ¥æ‰¾debug.log
        const sessions = fs.readdirSync(logsBaseDir);
        for (const session of sessions) {
          const debugLog = path.join(logsBaseDir, session, 'debug.log');
          
          if (fs.existsSync(debugLog)) {
            const stats = fs.statSync(debugLog);
            // æ£€æŸ¥æ–‡ä»¶ä¿®æ”¹æ—¶é—´æ˜¯å¦åœ¨ç›‘æ§å¼€å§‹ä¹‹å
            if (stats.mtimeMs > startTime && debugLog !== monitoredLog) {
              console.log(`âœ… å‘ç°æ´»åŠ¨æ—¥å¿—: ${session}`);
              console.log(`ğŸ“„ å¼€å§‹è·Ÿè¸ª: ${debugLog}\n`);
              
              // å¦‚æœå·²æœ‰tailè¿›ç¨‹ï¼Œå…ˆåœæ­¢
              if (currentTail) {
                currentTail.kill();
              }
              
              monitoredLog = debugLog;
              
              // å¼€å§‹tail -f
              const { spawn } = require('child_process');
              currentTail = spawn('tail', ['-f', debugLog]);
              
              currentTail.stdout.on('data', (data) => {
                process.stdout.write(data);
              });
              
              currentTail.stderr.on('data', (data) => {
                console.error(`é”™è¯¯: ${data}`);
              });
              
              currentTail.on('close', (code) => {
                if (code !== 0 && code !== null) {
                  console.log(`\ntailè¿›ç¨‹é€€å‡ºï¼Œä»£ç  ${code}`);
                }
                currentTail = null;
              });
              
              return; // æ‰¾åˆ°ååœæ­¢è¿™æ¬¡æ£€æŸ¥
            }
          }
        }
        
        // ç»§ç»­æ£€æŸ¥
        setTimeout(checkForLogs, 1000);
      };
      
      checkForLogs();
      
      // å¤„ç†Ctrl+C
      process.on('SIGINT', () => {
        if (currentTail) {
          currentTail.kill();
        }
        console.log('\nğŸ‘‹ åœæ­¢ç›‘æ§');
        process.exit(0);
      });
      
      return; // é˜»æ­¢æ‰§è¡Œåç»­ä»£ç 
    } else if (options.follow) {
      // ä¼ ç»Ÿçš„ tail -f æ¨¡å¼ï¼šè·Ÿè¸ªç°æœ‰æ—¥å¿—
      console.log('ğŸ“¡ å®æ—¶è·Ÿè¸ªæ—¥å¿— (Ctrl+C é€€å‡º)...\n');
      const { spawn } = require('child_process');
      const tail = spawn('tail', ['-f', targetLog]);
      
      tail.stdout.on('data', (data) => {
        process.stdout.write(data);
      });
      
      tail.stderr.on('data', (data) => {
        console.error(`é”™è¯¯: ${data}`);
      });
      
      tail.on('close', (code) => {
        if (code !== 0) {
          console.log(`tailè¿›ç¨‹é€€å‡ºï¼Œä»£ç  ${code}`);
        }
      });
      
      // å¤„ç†Ctrl+C
      process.on('SIGINT', () => {
        tail.kill();
        console.log('\nğŸ‘‹ åœæ­¢è·Ÿè¸ª');
        process.exit(0);
      });
      
      return;
    } else {
      // æ˜¾ç¤ºæœ€åNè¡Œ
      try {
        const content = fs.readFileSync(targetLog, 'utf-8');
        const lines = content.split('\n');
        const lastLines = lines.slice(-parseInt(options.lines) - 1).join('\n');
        
        console.log('');
        console.log('â”€'.repeat(60));
        console.log(lastLines);
        console.log('â”€'.repeat(60));
        console.log(`\nğŸ“ æ—¥å¿—ä½ç½®: ${targetLog}`);
        console.log(`ğŸ’¡ ä½¿ç”¨ -f å‚æ•°å®æ—¶è·Ÿè¸ªæ—¥å¿—`);
      } catch (err) {
        console.error('âŒ è¯»å–æ—¥å¿—å¤±è´¥:', err.message);
      }
    }
  });

// clean å‘½ä»¤ - æ¸…ç†æ—¥å¿—
program
  .command('clean')
  .description('æ¸…ç†ç›‘å·¥ç³»ç»Ÿçš„ä¸´æ—¶æ–‡ä»¶å’Œæ—¥å¿—')
  .option('--all', 'æ¸…ç†æ‰€æœ‰é¡¹ç›®çš„æ—¥å¿—')
  .option('--days <number>', 'æ¸…ç†Nå¤©å‰çš„æ—¥å¿—', '7')
  .action(async (options) => {
    console.log('ğŸ§¹ æ¸…ç†ç›‘å·¥ç³»ç»Ÿæ—¥å¿—...');
    
    const projectDir = process.cwd();
    const projectName = projectDir.replace(/\//g, '-');
    const logsBaseDir = options.all ? '/tmp/cc-supervisor' : `/tmp/cc-supervisor/${projectName}`;
    
    if (!fs.existsSync(logsBaseDir)) {
      console.log('âœ… æ²¡æœ‰éœ€è¦æ¸…ç†çš„æ—¥å¿—');
      return;
    }
    
    try {
      const days = parseInt(options.days);
      const cutoffTime = Date.now() - (days * 24 * 60 * 60 * 1000);
      let cleanedCount = 0;
      
      // é€’å½’æ¸…ç†æ—§æ—¥å¿—
      const cleanDir = (dir) => {
        const items = fs.readdirSync(dir);
        items.forEach(item => {
          const itemPath = path.join(dir, item);
          const stats = fs.statSync(itemPath);
          
          if (stats.isDirectory()) {
            // æ£€æŸ¥ç›®å½•æ—¶é—´
            if (stats.mtime.getTime() < cutoffTime) {
              fs.rmSync(itemPath, { recursive: true, force: true });
              cleanedCount++;
              console.log(`  ğŸ—‘ï¸ åˆ é™¤: ${item}`);
            } else if (options.all) {
              cleanDir(itemPath); // é€’å½’æ¸…ç†å­ç›®å½•
            }
          }
        });
      };
      
      cleanDir(logsBaseDir);
      
      if (cleanedCount > 0) {
        console.log(`âœ… æ¸…ç†äº† ${cleanedCount} ä¸ªæ—§æ—¥å¿—ç›®å½•`);
      } else {
        console.log('âœ… æ²¡æœ‰éœ€è¦æ¸…ç†çš„æ—§æ—¥å¿—');
      }
      
    } catch (err) {
      console.error('âŒ æ¸…ç†å¤±è´¥:', err.message);
    }
  });

// è§£æå‘½ä»¤è¡Œå‚æ•°
program.parse();

// å¦‚æœæ²¡æœ‰æä¾›å‘½ä»¤ï¼Œæ˜¾ç¤ºå¸®åŠ©
if (!process.argv.slice(2).length) {
  program.outputHelp();
}