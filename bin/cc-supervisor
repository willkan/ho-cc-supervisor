#!/usr/bin/env node

/**
 * CC-Supervisor - Claude智能监工
 * 极简CLI，只提供初始化功能
 */

const { program } = require('commander');
const path = require('path');
const fs = require('fs');
const { execSync } = require('child_process');

// 设置版本和描述
program
  .name('cc-supervisor')
  .description('Claude智能监工 - 防止Claude偷懒的极简Hook系统')
  .version('3.0.0');

// init 命令 - 初始化监工系统
program
  .command('init')
  .description('初始化Claude监工系统')
  .action(async () => {
    console.log('🚀 初始化 Claude 智能监工...');
    
    try {
      // 创建 .claude 目录
      const claudeDir = '.claude';
      const hooksDir = path.join(claudeDir, 'hooks');
      
      if (!fs.existsSync(claudeDir)) {
        fs.mkdirSync(claudeDir, { recursive: true });
      }
      
      if (!fs.existsSync(hooksDir)) {
        fs.mkdirSync(hooksDir, { recursive: true });
      }

      // 复制监工Hook脚本（从templates目录）
      const packageRoot = path.join(__dirname, '..');
      const sourceHook = path.join(packageRoot, 'templates', 'hooks', 'cc-supervisor-stop.sh');
      const sourceRules = path.join(packageRoot, 'templates', 'cc-supervisor-rules.txt');
      const sourceConfig = path.join(packageRoot, 'templates', 'cc-supervisor-config.json');
      
      // 使用更具体的文件名避免冲突
      const targetHook = path.join(hooksDir, 'cc-supervisor-stop.sh');
      const targetRules = path.join(claudeDir, 'cc-supervisor-rules.txt');
      const targetConfig = path.join(claudeDir, 'cc-supervisor-config.json');

      if (fs.existsSync(sourceHook)) {
        fs.copyFileSync(sourceHook, targetHook);
        fs.chmodSync(targetHook, 0o755);
        console.log('📄 监工Hook已安装');
      }

      if (fs.existsSync(sourceRules)) {
        if (!fs.existsSync(targetRules)) {
          fs.copyFileSync(sourceRules, targetRules);
          console.log('📋 默认监工规则已安装');
        } else {
          console.log('⏭️ 保留现有监工规则');
        }
      }

      if (fs.existsSync(sourceConfig)) {
        if (!fs.existsSync(targetConfig)) {
          fs.copyFileSync(sourceConfig, targetConfig);
          console.log('⚙️ 监工配置文件已安装');
        } else {
          console.log('⏭️ 保留现有监工配置');
        }
      }

      // 更新或创建 settings.json
      const settingsPath = path.join(claudeDir, 'settings.json');
      let settings = { hooks: {} };
      
      if (fs.existsSync(settingsPath)) {
        try {
          settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        } catch (err) {
          console.log('⚠️ 现有settings.json格式错误，将创建新的');
        }
      }

      // 配置Stop Hook (官方格式) - 20分钟超时
      // 保留现有的Stop hooks，添加我们的
      if (!settings.hooks) {
        settings.hooks = {};
      }
      if (!settings.hooks.Stop) {
        settings.hooks.Stop = [];
      }
      
      // 检查是否已经有我们的hook
      const ourHookCommand = "$CLAUDE_PROJECT_DIR/.claude/hooks/cc-supervisor-stop.sh";
      let hasOurHook = false;
      
      for (const stopConfig of settings.hooks.Stop) {
        if (stopConfig.hooks) {
          for (const hook of stopConfig.hooks) {
            if (hook.command === ourHookCommand) {
              hasOurHook = true;
              // 更新超时时间
              hook.timeout = 1200;
              break;
            }
          }
        }
      }
      
      // 如果没有我们的hook，添加它
      if (!hasOurHook) {
        settings.hooks.Stop.push({
          "hooks": [{
            "type": "command",
            "command": ourHookCommand,
            "timeout": 1200
          }]
        });
      }

      fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
      console.log('⚙️ Claude Code settings已更新');

      console.log('');
      console.log('✅ Claude智能监工初始化完成！');
      console.log('');
      console.log('📖 使用说明:');
      console.log('1. 启动Claude Code正常工作');
      console.log('2. 监工会自动检查Claude的工作质量');
      console.log('3. 发现偷懒行为时会自动要求重做');
      console.log('4. 可编辑 .claude/cc-supervisor-rules.txt 自定义监工规则');
      console.log('5. 可编辑 .claude/cc-supervisor-config.json 配置Claude命令参数');

    } catch (err) {
      console.error('❌ 初始化失败:', err.message);
      process.exit(1);
    }
  });

// logs 命令 - 查看调试日志
program
  .command('logs')
  .description('查看监工系统的调试日志')
  .option('-f, --follow', '实时跟踪最新的现有日志 (tail -f)')
  .option('-w, --watch', '等待并监控新的监工session')
  .option('-n, --lines <number>', '显示最后N行日志', '20')
  .option('--session <id>', '查看特定session的日志')
  .option('--list', '列出所有可用的日志文件')
  .action(async (options) => {
    console.log('📋 查看监工调试日志...');
    
    const projectDir = process.cwd();
    const projectName = projectDir.replace(/\//g, '-');
    const logsBaseDir = `/tmp/cc-supervisor/${projectName}`;
    
    // 列出所有日志
    if (options.list) {
      try {
        if (!fs.existsSync(logsBaseDir)) {
          console.log('❌ 当前项目没有调试日志');
          return;
        }
        
        const sessions = fs.readdirSync(logsBaseDir);
        if (sessions.length === 0) {
          console.log('❌ 没有找到任何session日志');
          return;
        }
        
        console.log('\n可用的Session日志:');
        sessions.forEach(session => {
          const debugLog = path.join(logsBaseDir, session, 'debug.log');
          if (fs.existsSync(debugLog)) {
            const stats = fs.statSync(debugLog);
            console.log(`  📁 ${session}`);
            console.log(`     创建时间: ${stats.birthtime.toLocaleString()}`);
            console.log(`     文件大小: ${(stats.size / 1024).toFixed(2)} KB`);
          }
        });
        return;
      } catch (err) {
        console.error('❌ 读取日志目录失败:', err.message);
        return;
      }
    }
    
    // 查看特定session或最新的日志
    let targetLog;
    
    if (options.session) {
      targetLog = path.join(logsBaseDir, options.session, 'debug.log');
    } else {
      // 找最新的日志
      try {
        if (!fs.existsSync(logsBaseDir)) {
          console.log('❌ 当前项目没有调试日志');
          console.log('💡 提示: 调试日志在监工检查时生成');
          return;
        }
        
        const sessions = fs.readdirSync(logsBaseDir)
          .map(name => ({
            name,
            path: path.join(logsBaseDir, name, 'debug.log'),
            time: fs.existsSync(path.join(logsBaseDir, name, 'debug.log')) 
              ? fs.statSync(path.join(logsBaseDir, name, 'debug.log')).mtime 
              : 0
          }))
          .filter(s => s.time > 0)
          .sort((a, b) => b.time - a.time);
        
        if (sessions.length === 0) {
          console.log('❌ 没有找到调试日志');
          return;
        }
        
        targetLog = sessions[0].path;
        console.log(`📂 查看最新日志: ${sessions[0].name}`);
      } catch (err) {
        console.error('❌ 查找日志失败:', err.message);
        return;
      }
    }
    
    // 检查日志文件是否存在
    if (!fs.existsSync(targetLog)) {
      console.log(`❌ 日志文件不存在: ${targetLog}`);
      return;
    }
    
    // 显示日志内容
    if (options.watch) {
      // 监控模式：等待新的session
      console.log('📡 等待新的监工session... (Ctrl+C 退出)');
      console.log(`监控目录: ${logsBaseDir}\n`);
      
      const startTime = Date.now();
      let currentTail = null;
      let monitoredLog = null;
      
      // 监控目录，找到新的或更新的debug.log
      const checkForLogs = () => {
        if (!fs.existsSync(logsBaseDir)) {
          // 目录还不存在，继续等待
          setTimeout(checkForLogs, 1000);
          return;
        }
        
        // 遍历所有session查找debug.log
        const sessions = fs.readdirSync(logsBaseDir);
        for (const session of sessions) {
          const debugLog = path.join(logsBaseDir, session, 'debug.log');
          
          if (fs.existsSync(debugLog)) {
            const stats = fs.statSync(debugLog);
            // 检查文件修改时间是否在监控开始之后
            if (stats.mtimeMs > startTime && debugLog !== monitoredLog) {
              console.log(`✅ 发现活动日志: ${session}`);
              console.log(`📄 开始跟踪: ${debugLog}\n`);
              
              // 如果已有tail进程，先停止
              if (currentTail) {
                currentTail.kill();
              }
              
              monitoredLog = debugLog;
              
              // 开始tail -f
              const { spawn } = require('child_process');
              currentTail = spawn('tail', ['-f', debugLog]);
              
              currentTail.stdout.on('data', (data) => {
                process.stdout.write(data);
              });
              
              currentTail.stderr.on('data', (data) => {
                console.error(`错误: ${data}`);
              });
              
              currentTail.on('close', (code) => {
                if (code !== 0 && code !== null) {
                  console.log(`\ntail进程退出，代码 ${code}`);
                }
                currentTail = null;
              });
              
              return; // 找到后停止这次检查
            }
          }
        }
        
        // 继续检查
        setTimeout(checkForLogs, 1000);
      };
      
      checkForLogs();
      
      // 处理Ctrl+C
      process.on('SIGINT', () => {
        if (currentTail) {
          currentTail.kill();
        }
        console.log('\n👋 停止监控');
        process.exit(0);
      });
      
      return; // 阻止执行后续代码
    } else if (options.follow) {
      // 传统的 tail -f 模式：跟踪现有日志
      console.log('📡 实时跟踪日志 (Ctrl+C 退出)...\n');
      const { spawn } = require('child_process');
      const tail = spawn('tail', ['-f', targetLog]);
      
      tail.stdout.on('data', (data) => {
        process.stdout.write(data);
      });
      
      tail.stderr.on('data', (data) => {
        console.error(`错误: ${data}`);
      });
      
      tail.on('close', (code) => {
        if (code !== 0) {
          console.log(`tail进程退出，代码 ${code}`);
        }
      });
      
      // 处理Ctrl+C
      process.on('SIGINT', () => {
        tail.kill();
        console.log('\n👋 停止跟踪');
        process.exit(0);
      });
      
      return;
    } else {
      // 显示最后N行
      try {
        const content = fs.readFileSync(targetLog, 'utf-8');
        const lines = content.split('\n');
        const lastLines = lines.slice(-parseInt(options.lines) - 1).join('\n');
        
        console.log('');
        console.log('─'.repeat(60));
        console.log(lastLines);
        console.log('─'.repeat(60));
        console.log(`\n📍 日志位置: ${targetLog}`);
        console.log(`💡 使用 -f 参数实时跟踪日志`);
      } catch (err) {
        console.error('❌ 读取日志失败:', err.message);
      }
    }
  });

// clean 命令 - 清理日志
program
  .command('clean')
  .description('清理监工系统的临时文件和日志')
  .option('--all', '清理所有项目的日志')
  .option('--days <number>', '清理N天前的日志', '7')
  .action(async (options) => {
    console.log('🧹 清理监工系统日志...');
    
    const projectDir = process.cwd();
    const projectName = projectDir.replace(/\//g, '-');
    const logsBaseDir = options.all ? '/tmp/cc-supervisor' : `/tmp/cc-supervisor/${projectName}`;
    
    if (!fs.existsSync(logsBaseDir)) {
      console.log('✅ 没有需要清理的日志');
      return;
    }
    
    try {
      const days = parseInt(options.days);
      const cutoffTime = Date.now() - (days * 24 * 60 * 60 * 1000);
      let cleanedCount = 0;
      
      // 递归清理旧日志
      const cleanDir = (dir) => {
        const items = fs.readdirSync(dir);
        items.forEach(item => {
          const itemPath = path.join(dir, item);
          const stats = fs.statSync(itemPath);
          
          if (stats.isDirectory()) {
            // 检查目录时间
            if (stats.mtime.getTime() < cutoffTime) {
              fs.rmSync(itemPath, { recursive: true, force: true });
              cleanedCount++;
              console.log(`  🗑️ 删除: ${item}`);
            } else if (options.all) {
              cleanDir(itemPath); // 递归清理子目录
            }
          }
        });
      };
      
      cleanDir(logsBaseDir);
      
      if (cleanedCount > 0) {
        console.log(`✅ 清理了 ${cleanedCount} 个旧日志目录`);
      } else {
        console.log('✅ 没有需要清理的旧日志');
      }
      
    } catch (err) {
      console.error('❌ 清理失败:', err.message);
    }
  });

// 解析命令行参数
program.parse();

// 如果没有提供命令，显示帮助
if (!process.argv.slice(2).length) {
  program.outputHelp();
}